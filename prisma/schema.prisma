generator client {
  provider = "prisma-client-js"
}

generator typegraphql {
  provider = "typegraphql-prisma"
  output   = "../src/generated/typegraphql-prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// ### Enums

// Defines the different roles a user can have within the platform, determining their permissions and access levels.
enum UserRole {
  /// The primary owner with full control over the platform.
  OWNER

  /// An administrative user with elevated permissions.
  ADMIN

  /// A regular user with standard access.
  USER
}

// Represents the various types of strategies that can be used for trading.
enum TradeStrategy {
  /// Analyzes historical price data to predict future movements.
  TECHNICAL_ANALYSIS

  /// Follows the trend of an asset's price movement.
  TREND_FOLLOWING

  /// Capitalizes on price discrepancies between assets.
  MEAN_REVERSION

  /// Uses options contracts to hedge risk or generate income.
  OPTIONS_STRATEGY

  /// Utilizes momentum to amplify returns on investments.
  MOMENTUM_STRATEGY

  /// Exploits price differences between markets or related assets.
  ARBITRAGE

  /// Uses statistical methods to identify profitable trades.
  STATISTICAL_ARBITRAGE

  /// Provides liquidity to the market by continuously buying and selling.
  MARKET_MAKING

  /// Uses news events to predict and capitalize on market movements.
  NEWS_BASED_STRATEGY

  /// Analyzes sentiment data to predict market movements.
  SENTIMENT_ANALYSIS

  /// Supplies liquidity to earn profits from bid-ask spreads.
  LIQUIDITY_PROVISION

  /// Profits from small price changes by executing numerous trades.
  SCALPING

  /// Trades based on volatility patterns in the market.
  VOLATILITY_TRADING

  /// Executes trades based on economic indicators and data releases.
  EVENT_DRIVEN

  /// Trades based on breakout patterns from established support or resistance levels.
  BREAKOUT_STRATEGY

  /// Trades based on the flow and volume of orders in the market.
  ORDER_FLOW_TRADING

  /// Pairs assets to capitalize on relative price movements between them.
  PAIR_TRADING

  /// Trades based on the rotation of funds between different market sectors.
  SECTOR_ROTATION

  /// Executes a large number of trades at high speed to capitalize on small price changes.
  HIGH_FREQUENCY_TRADING

  /// Utilizes machine vision techniques to analyze market data and execute trades.
  MACHINE_VISION_ANALYSIS

  /// No specific strategy or approach to trading.
  NO_STRATEGY
}

// Represents the various types of signals that can be discerned from market data.
enum TradeSignal {
  /// A bullish signal when a short-term moving average crosses above a long-term moving average.
  GOLDEN_CROSS

  /// Signal generated when a short-term moving average crosses above or below a long-term moving average.
  MOVING_AVERAGE_CROSSOVER

  /// Indicates that the Relative Strength Index (RSI) is over the overbought threshold.
  RSI_OVERBOUGHT

  /// Indicates that the Relative Strength Index (RSI) is below the oversold threshold.
  RSI_OVERSOLD

  /// A signal generated by the Moving Average Convergence Divergence (MACD) indicator crossing.
  MACD_CROSSOVER

  /// Occurs when the price breaks above or below the Bollinger Bands.
  BOLLINGER_BANDS_BREAKOUT

  /// A signal indicating a reversal in the current trend.
  TREND_REVERSAL

  /// A sudden increase in market volatility.
  VOLATILITY_SPIKE

  /// Signals based on specific price patterns and actions.
  PRICE_ACTION

  /// A surge in the implied volatility of options contracts.
  IMPLIED_VOLATILITY_SURGE

  /// When the price breaks above a resistance level, indicating potential upward movement.
  BREAKOUT_ABOVE_RESISTANCE

  /// When the price breaks below a support level, indicating potential downward movement.
  BREAKDOWN_BELOW_SUPPORT

  /// When the price holds above a support level, indicating strength.
  SUPPORT_LEVEL_HOLD

  /// When the price holds below a resistance level, indicating weakness.
  RESISTANCE_LEVEL_HOLD

  /// Signals based on Fibonacci retracement levels.
  FIBONACCI_RETRACEMENT

  /// Wave patterns identified using Elliott Wave theory.
  ELLIOTT_WAVE

  /// Signals generated by the Parabolic SAR indicator.
  PARABOLIC_SAR

  /// Indicates the strength of a trend based on the Average Directional Index (ADX).
  ADX_TREND_STRENGTH

  /// Indicates that the Commodity Channel Index (CCI) is over the overbought threshold.
  CCI_OVERBOUGHT

  /// Indicates that the Commodity Channel Index (CCI) is below the oversold threshold.
  CCI_OVERSOLD

  /// Indicates that the Stochastic Oscillator is below the oversold threshold.
  STOCHASTIC_OVERSOLD

  /// Indicates that the Stochastic Oscillator is above the overbought threshold.
  STOCHASTIC_OVERBOUGHT

  /// Signals based on divergence between price and an indicator.
  DIVERGENCE_SIGNAL

  /// Patterns identified using Gann Fan techniques.
  GANN_FAN

  /// Occurs when the price breaks out of the Donchian Channels.
  DONCHIAN_CHANNEL_BREAKOUT

  /// Signals based on pivot point levels.
  PIVOT_POINT

  /// Occurs when the price breaks out of the Keltner Channels.
  KELTNER_CHANNEL_BREAK

  /// Signals generated by the Heikin Ashi moving average crossover.
  HEIKIN_ASHI_CROSSOVER

  /// A sudden surge in trading volume.
  VOLUME_SURGE

  /// Imbalance in the order book indicating potential price movement.
  ORDER_BOOK_IMBALANCE

  /// Anomalies detected in time series data.
  TIME_SERIES_ANOMALY

  /// Level indicating potential mean reversion trading opportunities.
  MEAN_REVERSION_LEVEL

  /// Signals based on pair trading strategies.
  PAIR_TRADING_SIGNAL

  /// Thresholds based on sentiment score.
  SENTIMENT_SCORE_THRESHOLD

  /// Changes in news sentiment related to the asset.
  NEWS_SENTIMENT_CHANGE

  /// Impact of order flow on price movement.
  ORDER_FLOW_IMPACT

  /// Movements driven by liquidity in the market.
  LIQUIDITY_DRIVEN_MOVE

  /// Predictions generated by machine learning models.
  MACHINE_LEARNING_PREDICTION

  /// Triggers based on sentiment analysis.
  SENTIMENT_ANALYSIS_TRIGGER

  /// No specific signal or reason for the trade.
  NO_SIGNAL
}

// Represents the various types of financial assets supported by the trading platform.
enum AssetType {
  /// Represents a share of ownership in a corporation.
  STOCK

  /// Exchange-Traded Fund, a type of investment fund traded on stock exchanges.
  ETF

  /// A mutual fund that pools money from many investors to purchase securities.
  MUTUAL_FUND

  /// Digital or virtual currencies using cryptography for security.
  CRYPTOCURRENCY

  /// A market index representing a collection of stocks.
  INDEX

  /// Physical goods such as gold, oil, or agricultural products.
  COMMODITY

  /// Traditional currencies used in international trade.
  CURRENCY

  /// Contracts that give the holder the right to buy or sell an asset at a set price.
  OPTION

  /// Financial contracts obligating the buyer to purchase an asset at a future date.
  FUTURE

  /// Debt securities issued by entities to raise capital.
  BOND

  /// Securities that give the holder the right to purchase stock at a specific price.
  WARRANT

  /// American Depositary Receipts representing shares in foreign companies.
  ADR

  /// Global Depositary Receipts representing shares in foreign companies.
  GDR

  /// Units of ownership in investment funds or trusts.
  UNIT

  /// Rights granted to shareholders, such as voting or dividend rights.
  RIGHT

  /// Real Estate Investment Trusts, companies that own or finance income-producing real estate.
  REIT

  /// Investment products structured to meet specific needs.
  STRUCTURED_PRODUCT

  /// Financial contracts to exchange cash flows between parties.
  SWAP

  /// Immediate exchange of financial instruments.
  SPOT

  /// Agreements to buy or sell an asset at a future date.
  FORWARD

  /// Any other type of asset not classified above.
  OTHER
}

// Specifies the type of Alpaca account being used.
enum AlpacaAccountType {
  /// A simulated trading account for testing strategies without real money.
  PAPER

  /// A live trading account with real funds.
  LIVE
}

// Enumerates the possible actions that can be performed on a trade.
enum ActionType {
  /// Initiates a purchase of an asset.
  BUY

  /// Identifies a suitable option contract and initiates its purchase.
  BUY_OPTION

  /// Exercises an option to buy or sell the underlying asset.
  EXERCISE_OPTION

  /// Initiates the sale of an asset.
  SELL

  /// Cancels an existing trade action.
  CANCEL

  /// Modifies the parameters of an existing trade.
  ADJUST

  /// Implements a hedging strategy to mitigate risk.
  HEDGE
}

// Indicates the side of a trade action, whether buying or selling.
enum OrderSide {
  /// Represents the buying side of a trade action.
  BUY

  /// Represents the selling side of a trade action.
  SELL
}

// Represents the current status of a trade action.
enum ActionStatus {
  /// The trade action is planned and awaiting execution.
  STAGED

  /// The trade action has been executed but not yet finalized.
  EXECUTED

  /// The trade action has been fully completed.
  COMPLETED
}

// Indicates the current status of a trade.
enum TradeStatus {
  /// The trade is pending and has not yet been processed.
  PENDING

  /// The trade is currently open and active.
  OPEN

  /// The trade is partially filled.
  PARTIAL

  /// The trade has been fully completed.
  COMPLETED
}

// Defines the types of orders that can be placed in the market.
enum OrderType {
  /// Executes immediately at the best available current market price.
  MARKET

  /// Executes only at the specified limit price or better.
  LIMIT

  /// Becomes a market order once the stop price is triggered.
  STOP

  /// Becomes a limit order once the stop price is triggered.
  STOP_LIMIT

  /// Adjusts the stop price based on a specified trail amount or percentage.
  TRAILING_STOP
}

// Defines the class of advanced order types that can be placed.
enum OrderClass {
  /// A single standalone order without additional conditions.
  SIMPLE

  /// A primary order with attached take-profit and stop-loss orders to automatically manage the trade.
  BRACKET

  /// OCO (One-Cancels-Other): A pair of orders where the execution of one cancels the other.
  OCO

  /// OSO (One Sends Other): A chain of orders where the execution of one order triggers the placement of another.
  OSO

  /// OTO (One-Triggers-Other): Similar to BRACKET, where the execution of one order triggers the placement of another.
  OTO
}

// Specifies the type of option contract (CALL or PUT).
enum OptionType {
  /// A contract that gives the holder the right to buy the underlying asset.
  CALL

  /// A contract that gives the holder the right to sell the underlying asset.
  PUT
}

enum OrderStatus {
  /// The order has been staged in Adaptic to be sent to Alpaca. This is the initial status.
  STAGED

  /// The order has been received by Alpaca, and routed to exchanges for execution. This is the usual initial state of an order after being received.
  NEW

  /// The order has been partially filled.
  PARTIALLY_FILLED

  /// The order has been filled, and no further updates will occur for the order.
  FILLED

  /// The order is done executing for the day, and will not receive further updates until the next trading day.
  DONE_FOR_DAY

  /// The order has been canceled, and no further updates will occur for the order. This can be either due to a cancel request by the user, or the order has been canceled by the exchanges due to its time-in-force.
  CANCELED

  /// The order has expired, and no further updates will occur for the order.
  EXPIRED

  /// The order was replaced by another order, or was updated due to a market event such as corporate action.
  REPLACED

  /// The order is waiting to be canceled.
  PENDING_CANCEL

  /// The order is waiting to be replaced by another order. The order will reject cancel request while in this state.
  PENDING_REPLACE

  /// The order has been received by Alpaca, but hasn’t yet been routed to the execution venue. This could be seen often outside of trading session hours.
  ACCEPTED

  /// The order has been received by Alpaca, and routed to the exchanges, but has not yet been accepted for execution. This state only occurs on rare occasions.
  PENDING_NEW

  /// The order has been received by exchanges, and is evaluated for pricing. This state only occurs on rare occasions.
  ACCEPTED_FOR_BIDDING

  /// The order has been stopped, and a trade is guaranteed for the order, usually at a stated price or better, but has not yet occurred. This state only occurs on rare occasions.
  STOPPED

  /// The order has been rejected, and no further updates will occur for the order. This state occurs on rare occasions and may occur based on various conditions decided by the exchanges.
  REJECTED

  /// The order has been suspended, and is not eligible for trading. This state only occurs on rare occasions.
  SUSPENDED

  /// The order has been completed for the day (either filled or done for day), but remaining settlement calculations are still pending. This state only occurs on rare occasions.
  CALCULATED
}

/// Time in force enum (day, gtc, opg, cls, etc.).
enum TimeInForce {
  /// The order is valid for the day and expires at market close.
  DAY

  /// The order is valid until canceled by the user.
  GTC

  /// The order is valid for the opening of the market.
  OPG

  /// The order is valid until the close of the market.
  CLS

  /// The order must be executed immediately or canceled.
  IOC

  /// The order must be executed immediately or canceled.
  FOK
}

// Categorizes the types of alerts that can be generated.
enum AlertType {
  /// Indicates a successful operation or event.
  SUCCESS

  /// Represents a warning that requires attention.
  WARNING

  /// Signifies an error that needs to be addressed.
  ERROR

  /// Provides informational messages to the user.
  INFO
}

// Specifies the importance level of an event.
enum EventImportance {
  /// Low importance events with minimal impact.
  LOW

  /// Medium importance events with noticeable impact.
  MEDIUM

  /// High importance events with significant impact.
  HIGH
}

// Defines the subscription plans available to users.
enum SubscriptionPlan {
  /// A free plan with limited features.
  FREE

  /// A professional plan with enhanced features.
  PRO

  /// A business plan tailored for organizational needs.
  BUSINESS
}

// OpenAI API language models available for text generation.
enum OpenaiModel {
  // gpt-4o model (OpenAI's high-intelligence flagship model for complex, multi-step tasks)
  GPT_4O

  // gpt-4o-mini model (OpenAI's affordable and intelligent small model for fast, lightweight tasks)
  GPT_4O_MINI

  // o1-preview model (OpenAI's latest model, trained with reinforcement learning to perform complex reasoning)
  O1_PREVIEW

  // o1-mini model (OpenAI's lightweight model for quick, simple tasks, of its latest language model)
  O1_MINI
}

/// ### Models

// Represents a user session for authentication purposes.
model Session {
  /// Unique identifier for the session. TYPESTRING.SKIP=true
  id String @id @default(cuid())

  /// Token associated with the session for authentication. TYPESTRING.SKIP=true
  sessionToken String @unique

  /// Reference to the user who owns this session. TYPESTRING.SKIP=true
  userId String @db.Uuid

  /// Expiration date and time of the session.
  expires DateTime

  /// Relation to the User model. TYPESTRING.INCLUDE=['id','name','email'] GQL.EXCLUDE=['alpacaAccounts']
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// Timestamp when the session was created. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the session was last updated. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  @@index([userId])
  @@map(name: "sessions")
}

// Represents a user of the trading platform.
model User {
  /// Unique identifier for the user. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// The user's full name.
  name String?

  /// The user's email address, must be unique.
  email String? @unique

  /// Timestamp when the user's email was verified. TYPESTRING.SKIP=true
  emailVerified DateTime?

  /// URL to the user's profile image.
  image String?

  /// Timestamp when the user account was created. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the user account was last updated. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  /// The role assigned to the user, determining permissions.
  role UserRole @default(USER)

  /// A short biography or description of the user.
  bio String?

  /// The user's job title or position.
  jobTitle String?

  /// The type of Alpaca account the user currently holds.
  currentAccount AlpacaAccountType @default(PAPER)

  /// Relation to the Customer model. TYPESTRING.INCLUDE=['id','name','plan'] GQL.EXCLUDE=['users']
  customer Customer? @relation(fields: [customerId], references: [id])

  /// Foreign key referencing the Customer. TYPESTRING.SKIP=true
  customerId Int?

  /// List of accounts associated with the user. TYPESTRING.SKIP=true GQL.EXCLUDE=['alpacaAccounts','user']
  accounts Account[]

  /// List of sessions associated with the user. TYPESTRING.SKIP=true GQL.EXCLUDE=['user']
  sessions Session[]

  /// List of authenticators for the user. TYPESTRING.SKIP=true GQL.EXCLUDE=['user']
  authenticators Authenticator[]

  /// The subscription plan the user is enrolled in.
  plan SubscriptionPlan?

  /// List of Alpaca accounts linked to the user. TYPESTRING.INCLUDE=['id','type'] GQL.EXCLUDE=['user']
  alpacaAccounts AlpacaAccount[]

  /// OpenAI API key for the user.
  openaiAPIKey String?

  /// OpenAI API Language model selected by the user
  openaiModel OpenaiModel? @default(O1_MINI)

  @@map(name: "users")
}

// Represents an Alpaca trading account linked to a user.
model AlpacaAccount {
  /// Unique identifier for the Alpaca account. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// The type of Alpaca account (PAPER or LIVE).
  type AlpacaAccountType @default(PAPER)

  /// API key for authenticating requests to Alpaca. TYPESTRING.SKIP=true
  APIKey String

  /// API secret for authenticating requests to Alpaca. TYPESTRING.SKIP=true
  APISecret String

  /// JSON configuration settings for the Alpaca account.
  configuration Json?

  /// Indicates whether the market is currently open for trading.
  marketOpen Boolean @default(false)

  /// Minimum order size for the account. TYPESTRING.SKIP=true
  minOrderSize Float @default(500)

  /// Maximum order size for the account. TYPESTRING.SKIP=true
  maxOrderSize Float @default(100000)

  /// Minimum percentage change (from intraday high/low) to consider for a trade signal. TYPESTRING.SKIP=true
  minPercentageChange Float @default(0.01)

  /// Volume threshold for a trade signal (minimum volume qualifier to consider an asset for trading). TYPESTRING.SKIP=true
  volumeThreshold Float @default(50000)

  /// Relation to the User model who owns this Alpaca account. TYPESTRING.SKIP=true  GQL.EXCLUDE=['alpacaAccounts']
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// Foreign key referencing the User. TYPESTRING.SKIP=true
  userId String @db.Uuid

  /// Timestamp when the Alpaca account was created. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the Alpaca account was last updated. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  /// List of trades executed through this Alpaca account. TYPESTRING.SKIP=true GQL.EXCLUDE=['alpacaAccount']
  trades Trade[]

  /// List of orders placed through this Alpaca account. TYPESTRING.SKIP=true GQL.EXCLUDE=['alpacaAccount']
  orders Order[]

  /// List of positions held in this Alpaca account. TYPESTRING.INCLUDE=['id','qty','asset'] GQL.EXCLUDE=['alpacaAccount']
  positions Position[]

  /// List of alerts generated for this Alpaca account. TYPESTRING.SKIP=true GQL.EXCLUDE=['alpacaAccount']
  alerts Alert[]

  @@map(name: "alpaca_accounts")
}

// Represents a financial position held in an Alpaca account.
model Position {
  /// Unique identifier for the position. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// Reference to the associated asset. TYPESTRING.SKIP=true
  assetId String @db.Uuid

  /// Relation to the Asset model. TYPESTRING.INCLUDE=['symbol','name','type'] GQL.EXCLUDE=['symbol','name','type']
  asset Asset @relation(fields: [assetId], references: [id], onDelete: Cascade)

  /// The average price at which the asset was acquired.
  averageEntryPrice Float

  /// Total quantity of the asset held.
  qty Float

  /// Quantity of the asset available for trading.
  qtyAvailable Float

  /// Current market value of the position.
  marketValue Float

  /// Total cost basis of the position.
  costBasis Float

  /// Unrealized profit or loss of the position.
  unrealizedPL Float

  /// Unrealized profit or loss as a percentage.
  unrealizedPLPC Float

  /// Unrealized intraday profit or loss.
  unrealisedIntradayPL Float

  /// Unrealized intraday profit or loss as a percentage.
  unrealisedIntradayPLPC Float

  /// Current price of the asset.
  currentPrice Float

  /// Last traded price of the asset.
  lastTradePrice Float

  /// Price change of the asset for the day.
  changeToday Float

  /// Indicates if the asset is marginable.
  assetMarginable Boolean

  /// Relation to the AlpacaAccount model, if applicable. TYPESTRING.SKIP=true GQL.EXCLUDE=['alpacaAccount']
  alpacaAccount AlpacaAccount? @relation(fields: [alpacaAccountId], references: [id], onDelete: Cascade)

  /// Foreign key referencing the AlpacaAccount. TYPESTRING.SKIP=true
  alpacaAccountId String @db.Uuid
}

// Represents an authenticator for multi-factor authentication.
model Authenticator {
  /// Unique identifier for the authenticator. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// Reference to the user who owns this authenticator. TYPESTRING.SKIP=true
  userId String @db.Uuid

  /// Unique credential ID for the authenticator. TYPESTRING.SKIP=true
  credentialID String @unique

  /// Public key associated with the authenticator. TYPESTRING.SKIP=true
  publicKey String

  /// Counter for the number of authentication attempts. TYPESTRING.SKIP=true
  counter Int

  /// Relation to the User model. TYPESTRING.SKIP=true GQL.EXCLUDE=['authenticators']
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// Timestamp when the authenticator was created. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the authenticator was last updated. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  @@index([userId])
  @@map(name: "authenticators")
}

// Represents an external account linked to a user for authentication.
model Account {
  /// Unique identifier for the account. TYPESTRING.SKIP=true
  id String @id @default(cuid())

  /// Reference to the user who owns this account. TYPESTRING.SKIP=true
  userId String @db.Uuid

  /// Type of the account (e.g., OAuth provider).
  type String

  /// Provider of the account (e.g., Google, GitHub).
  provider String

  /// Unique identifier provided by the external provider.
  providerAccountId String

  /// Refresh token for the external account, if applicable. TYPESTRING.SKIP=true
  refresh_token String? @db.Text

  /// Access token for the external account, if applicable. TYPESTRING.SKIP=true
  access_token String? @db.Text

  /// Expiration time of the access token.
  expires_at Int?

  /// Type of the token (e.g., Bearer).
  token_type String?

  /// Scope of access granted by the token.
  scope String?

  /// ID token for authentication, if applicable. TYPESTRING.SKIP=true
  id_token String? @db.Text

  /// State of the session associated with the account.
  session_state String?

  /// Timestamp when the account was created. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the account was last updated. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  /// Relation to the User model. TYPESTRING.SKIP=true GQL.EXCLUDE=['accounts']
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map(name: "accounts")
}

// Represents a token used for verifying user actions, such as password resets.
model VerificationToken {
  /// Unique identifier for the verification token. TYPESTRING.SKIP=true
  id String @id @default(cuid())

  /// Identifier associated with the token (e.g., user ID). TYPESTRING.SKIP=true
  identifier String

  /// The verification token string, must be unique. TYPESTRING.SKIP=true
  token String @unique

  /// Expiration date and time of the token. TYPESTRING.SKIP=true
  expires DateTime

  @@unique([identifier, token])
  @@map(name: "verification_tokens")
}

// Represents a customer entity, which may include multiple users.
model Customer {
  /// Unique identifier for the customer. TYPESTRING.SKIP=true
  id Int @id @default(autoincrement())

  /// Reference to the authenticated user associated with the customer. TYPESTRING.SKIP=true
  authUserId String

  /// Name of the customer.
  name String?

  /// Subscription plan the customer is enrolled in.
  plan SubscriptionPlan?

  /// Unique Stripe customer ID for billing. TYPESTRING.SKIP=true
  stripeCustomerId String? @unique

  /// Unique Stripe subscription ID. TYPESTRING.SKIP=true
  stripeSubscriptionId String? @unique

  /// Stripe price ID associated with the customer's subscription. TYPESTRING.SKIP=true
  stripePriceId String?

  /// End date of the current billing period in Stripe.
  stripeCurrentPeriodEnd DateTime?

  /// Timestamp when the customer was created. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the customer was last updated. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  /// List of users associated with the customer. TYPESTRING.INCLUDE=['id','name','email'] GQL.EXCLUDE=['customer']
  users User[]

  @@index([authUserId])
}

// Represents a financial asset available for trading.
model Asset {
  /// Unique identifier for the asset. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// Ticker symbol of the asset, must be unique.
  symbol String @unique

  /// Full name of the asset, must be unique.
  name String @unique

  /// Type of the asset, defined by AssetType enum.
  type AssetType

  /// URL to the asset's logo image. TYPESTRING.SKIP=true
  logoUrl String?

  /// Description of the asset. TYPESTRING.SKIP=true
  description String?

  /// Central Index Key for the asset. TYPESTRING.SKIP=true
  cik String?

  /// Stock exchange where the asset is listed. TYPESTRING.SKIP=true
  exchange String?

  /// Currency in which the asset is traded. TYPESTRING.SKIP=true
  currency String?

  /// Country where the asset is based. TYPESTRING.SKIP=true
  country String?

  /// Sector classification of the asset. TYPESTRING.SKIP=true
  sector String?

  /// Industry classification of the asset. TYPESTRING.SKIP=true
  industry String?

  /// Physical address associated with the asset. TYPESTRING.SKIP=true
  address String?

  /// Official website of the asset. TYPESTRING.SKIP=true
  officialSite String?

  /// Fiscal year-end date of the asset. TYPESTRING.SKIP=true
  fiscalYearEnd String?

  /// Date of the latest financial quarter. TYPESTRING.SKIP=true
  latestQuarter String?

  /// Market capitalization of the asset. TYPESTRING.SKIP=true
  marketCapitalization String?

  /// Earnings Before Interest, Taxes, Depreciation, and Amortization. TYPESTRING.SKIP=true
  ebitda String?

  /// Price-to-Earnings ratio. TYPESTRING.SKIP=true
  peRatio String?

  /// Price/Earnings to Growth ratio. TYPESTRING.SKIP=true
  pegRatio String?

  /// Book value per share. TYPESTRING.SKIP=true
  bookValue String?

  /// Dividend per share. TYPESTRING.SKIP=true
  dividendPerShare String?

  /// Dividend yield percentage. TYPESTRING.SKIP=true
  dividendYield String?

  /// Earnings per share. TYPESTRING.SKIP=true
  eps String?

  /// Revenue per share over the trailing twelve months. TYPESTRING.SKIP=true
  revenuePerShareTTM String?

  /// Profit margin percentage. TYPESTRING.SKIP=true
  profitMargin String?

  /// Operating margin over the trailing twelve months. TYPESTRING.SKIP=true
  operatingMarginTTM String?

  /// Return on assets over the trailing twelve months. TYPESTRING.SKIP=true
  returnOnAssetsTTM String?

  /// Return on equity over the trailing twelve months. TYPESTRING.SKIP=true
  returnOnEquityTTM String?

  /// Total revenue over the trailing twelve months. TYPESTRING.SKIP=true
  revenueTTM String?

  /// Gross profit over the trailing twelve months. TYPESTRING.SKIP=true
  grossProfitTTM String?

  /// Diluted earnings per share over the trailing twelve months. TYPESTRING.SKIP=true
  dilutedEPSTTM String?

  /// Year-over-year growth in quarterly earnings. TYPESTRING.SKIP=true
  quarterlyEarningsGrowthYOY String?

  /// Year-over-year growth in quarterly revenue. TYPESTRING.SKIP=true
  quarterlyRevenueGrowthYOY String?

  /// Analyst target price for the asset. TYPESTRING.SKIP=true
  analystTargetPrice String?

  /// Percentage of analysts rating the asset as Strong Buy. TYPESTRING.SKIP=true
  analystRatingStrongBuy String?

  /// Percentage of analysts rating the asset as Buy. TYPESTRING.SKIP=true
  analystRatingBuy String?

  /// Percentage of analysts rating the asset as Hold. TYPESTRING.SKIP=true
  analystRatingHold String?

  /// Percentage of analysts rating the asset as Sell. TYPESTRING.SKIP=true
  analystRatingSell String?

  /// Percentage of analysts rating the asset as Strong Sell. TYPESTRING.SKIP=true
  analystRatingStrongSell String?

  /// Trailing Price-to-Earnings ratio. TYPESTRING.SKIP=true
  trailingPE String?

  /// Forward Price-to-Earnings ratio. TYPESTRING.SKIP=true
  forwardPE String?

  /// Price-to-Sales ratio over the trailing twelve months. TYPESTRING.SKIP=true
  priceToSalesRatioTTM String?

  /// Price-to-Book ratio. TYPESTRING.SKIP=true
  priceToBookRatio String?

  /// Enterprise Value to Revenue ratio. TYPESTRING.SKIP=true
  evToRevenue String?

  /// Enterprise Value to EBITDA ratio. TYPESTRING.SKIP=true
  evToEbitda String?

  /// Beta coefficient measuring volatility. TYPESTRING.SKIP=true
  beta String?

  /// 52-week high price of the asset. TYPESTRING.SKIP=true
  week52High String?

  /// 52-week low price of the asset. TYPESTRING.SKIP=true
  week52Low String?

  /// 50-day moving average price. TYPESTRING.SKIP=true
  day50MovingAverage String?

  /// 200-day moving average price. TYPESTRING.SKIP=true
  day200MovingAverage String?

  /// Total number of shares outstanding. TYPESTRING.SKIP=true
  sharesOutstanding String?

  /// Date when the next dividend is paid. TYPESTRING.SKIP=true
  dividendDate String?

  /// Date when the asset goes ex-dividend. TYPESTRING.SKIP=true
  exDividendDate String?

  /// Last ask price of the asset. TYPESTRING.SKIP=true
  askPrice String?

  /// Last bid price of the asset. TYPESTRING.SKIP=true
  bidPrice String?

  /// Timestamp when the asset was created in the database. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the asset was last updated in the database. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  /// List of trades involving this asset. TYPESTRING.SKIP=true GQL.EXCLUDE=['orders', 'positions', 'asset', 'alpacaAccount']
  trades Trade[]

  /// List of orders involving this asset. TYPESTRING.SKIP=true GQL.EXCLUDE=['trades', 'positions', 'asset', 'action', 'alpacaAccount']
  orders Order[]

  /// List of positions involving this asset. TYPESTRING.SKIP=true GQL.EXCLUDE=['asset', 'alpacaAccount']
  positions Position[]

  /// List of news article sentiments related to this asset. TYPESTRING.SKIP=true GQL.EXCLUDE=['asset']
  newsMentions NewsArticleAssetSentiment[]

  @@map(name: "assets")
}

// Represents a trade executed through an Alpaca account.
model Trade {
  /// Unique identifier for the trade. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// Reference to the Alpaca account used for the trade. TYPESTRING.SKIP=true
  alpacaAccountId String @db.Uuid

  /// Reference to the asset being traded. TYPESTRING.SKIP=true
  assetId String @db.Uuid

  /// Quantity of the asset being traded.
  qty Float

  /// Price at which the asset was traded.
  price Float

  /// Total value of the trade (qty * price).
  total Float

  /// Option Type (CALL or PUT) if the asset is an option.
  optionType OptionType? @default(CALL)

  /// Signal that triggered the trade.
  signal TradeSignal @default(PRICE_ACTION)

  /// Strategy used to execute the trade.
  strategy TradeStrategy @default(TECHNICAL_ANALYSIS)

  /// Analysis supporting the trade decision as markdown text. TYPESTRING.SKIP=true
  analysis String

  /// summary of the trade decision (this should be a short description of the trade).
  summary String

  /// Confidence level in the trade decision.
  confidence Float

  /// Timestamp when the trade was executed. TYPESTRING.SKIP=true
  timestamp DateTime @default(now()) @map(name: "timestamp")

  /// Timestamp when the trade record was created. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the trade record was last updated. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  /// Current status of the trade.
  status TradeStatus @default(PENDING)

  /// Relation to the AlpacaAccount model. TYPESTRING.SKIP=true GQL.EXCLUDE=['trades', 'orders', 'positions', 'user']
  alpacaAccount AlpacaAccount @relation(fields: [alpacaAccountId], references: [id], onDelete: Cascade)

  /// Relation to the Asset model. TYPESTRING.INCLUDE=['symbol','name','type'] GQL.EXCLUDE=['trades', 'orders', 'positions']
  asset Asset @relation(fields: [assetId], references: [id], onDelete: Cascade)

  /// List of actions associated with this trade. TYPESTRING.INCLUDE=["id","sequence","type","note","status","fee","order"] GQL.EXCLUDE=['trade']
  actions Action[]

  @@map(name: "trades")
}

// Represents an action performed as part of a trade.
model Action {
  /// Unique identifier for the action. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// Sequence number of the action within the trade.
  sequence Int

  /// Reference to the trade this action is part of. TYPESTRING.SKIP=true
  tradeId String @db.Uuid

  /// Type of trade action, defined by ActionType enum.
  type ActionType

  /// Additional notes or comments about the action.
  note String

  /// Current status of the trade action.
  status ActionStatus @default(STAGED)

  /// Fees associated with the action.
  fee Float?

  /// The trade this action is part of. TYPESTRING.SKIP=true GQL.EXCLUDE=['actions', 'orders', 'alpacaAccount', 'asset']
  trade Trade @relation(fields: [tradeId], references: [id], onDelete: Cascade)

  /// The order associated with this action. GQL.EXCLUDE=['action', 'alpacaAccount'] TYPESTRING.INCLUDE=["qty","notional","side","type","orderClass","timeInForce","limitPrice","stopPrice","stopLoss","takeProfit","trailPrice","trailPercent","extendedHours","status","submittedAt","strikePrice","expirationDate","optionType"]
  order Order? @relation

  @@map(name: "actions")
}

// Represents an order placed through an Alpaca account.
model Order {
  /// Unique identifier for the order. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// Client-supplied unique identifier for the order (from Alpaca). TYPESTRING.SKIP=true
  clientOrderId String? @unique

  /// Reference to the Alpaca account used for the order. TYPESTRING.SKIP=true
  alpacaAccountId String @db.Uuid

  /// Reference to the asset being ordered. TYPESTRING.SKIP=true
  assetId String @db.Uuid

  /// Quantity of the asset to be ordered.
  qty Float?

  /// Notional value of the order. Optional, used if qty is not provided. But importantly, either qty or notional must be provided.
  notional Float?

  /// Side of the order (BUY or SELL).
  side OrderSide @default(BUY)

  /// Type of order (market, limit, stop, stop_limit, trailing_stop).
  type OrderType @default(MARKET)

  /// Order class for advanced order types (simple, bracket, oco, oso).
  orderClass OrderClass @default(SIMPLE)

  /// Time in force for the order (day, gtc, opg, cls, ioc, fok).
  timeInForce TimeInForce @default(GTC)

  /// Must be a positive number and required for LIMIT or STOP_LIMIT orders. For take_profit, must be ≥ base_price + 0.01.
  limitPrice Float?

  /// Must be a positive number and required for STOP or STOP_LIMIT orders. It must be ≤ basePrice - 0.01.
  stopPrice Float?
  /// Stop loss object required for bracket orders.
  stopLoss StopLoss? @relation

  /// Take profit object required for bracket orders.
  takeProfit TakeProfit? @relation

  /// Must be a positive number and required for TRAILING_STOP orders.
  trailPrice Float?

  /// Must be a positive number representing the percentage and required for TRAILING_STOP orders.
  trailPercent Float?

  /// Whether the order is eligible for extended hours.
  extendedHours Boolean?

  /// Current status of the order.
  status OrderStatus @default(NEW)

  /// Timestamp when the order was created. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the order was last updated. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  /// Timestamp when the order was submitted.
  submittedAt DateTime?

  /// Timestamp when the order was filled.
  filledAt DateTime?

  /// Average price at which the order was filled.
  filledAvgPrice Float?

  /// Reference to the action associated with the order. TYPESTRING.SKIP=true
  actionId String @unique @db.Uuid

  /// The Alpaca account this order is associated with. TYPESTRING.SKIP=true  GQL.EXCLUDE=['trades', 'orders', 'positions', 'user']
  alpacaAccount AlpacaAccount @relation(fields: [alpacaAccountId], references: [id], onDelete: Cascade)

  /// The action this order is associated with. TYPESTRING.SKIP=true GQL.EXCLUDE=['trade', 'order']
  action Action @relation(fields: [actionId], references: [id], onDelete: Cascade)

  /// The asset this order is for. TYPESTRING.INCLUDE=['symbol','name','type'] GQL.EXCLUDE=['trade', 'order', 'positions', 'newsMentions']
  asset Asset @relation(fields: [assetId], references: [id], onDelete: Cascade)

  /// Fee associated with the order.
  fee Float?

  /// Strike price for option orders.
  strikePrice Float?

  /// Expiration date for option orders.
  expirationDate DateTime?

  /// If the asset.type is OPTION, then provide type of contract (CALL or PUT).
  optionType OptionType? @default(CALL)

  // Reference to the stop loss order associated with this order. TYPESTRING.SKIP=true
  stopLossId String? @unique @db.Uuid

  // Reference to the take profit order associated with this order. TYPESTRING.SKIP=true
  takeProfitId String? @db.Uuid

  @@map(name: "orders")
}

// Represents a stop loss order for a bracket order.
model StopLoss {
  /// Unique identifier for the stop loss order. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// Must be a positive number. For SELL orders: stopPrice ≤ current market price (must be ≤ base_price - 0.01). For BUY orders: stopPrice ≥ current market price (must be ≥ base_price + 0.01).
  stopPrice Float?

  /// Must be a positive number and required if parent Order's type is STOP_LIMIT.
  limitPrice Float?

  /// Timestamp when the stop loss order was created. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the stop loss order was last updated. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  /// Reference to the order associated with this stop loss.
  orderId String @unique @db.Uuid

  /// An order that is associated with this stop loss. GQL.SKIP=true
  Order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@map(name: "stop_losses")
}

// Represents a take profit order for a bracket order.
model TakeProfit {
  /// Unique identifier for the take profit order. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// Must be a positive number and ≥ base_price + 0.01.
  limitPrice Float?

  /// Typically not used in standard take profit orders. If used, must comply with Alpaca's specific requirements.
  stopPrice Float?

  /// Timestamp when the take profit order was created. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the take profit order was last updated. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  /// Reference to the order associated with this take profit.
  orderId String @unique @db.Uuid

  /// An order that is associated with this take profit. GQL.SKIP=true
  Order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@map(name: "take_profits")
}

// Represents an alert generated by the system for the user.
model Alert {
  /// Unique identifier for the alert. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// Reference to the Alpaca account associated with the alert. TYPESTRING.SKIP=true
  alpacaAccountId String @db.Uuid

  /// Message content of the alert.
  message String

  /// Type of the alert, defined by AlertType enum.
  type AlertType

  /// Indicates whether the alert has been read by the user.
  isRead Boolean @default(false)

  /// Timestamp when the alert was created. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the alert was last updated. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  /// Relation to the AlpacaAccount model. TYPESTRING.SKIP=true GQL.SKIP=true
  alpacaAccount AlpacaAccount @relation(fields: [alpacaAccountId], references: [id], onDelete: Cascade)

  @@map(name: "alerts")
}

// Represents a news article related to financial markets.
model NewsArticle {
  /// Unique identifier for the news article. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// Title of the news article.
  title String

  /// Full content of the news article.
  content String?

  /// Source of the news article (e.g., Bloomberg, Reuters).
  source String

  /// Domain of the source website.
  sourceDomain String?

  /// URL to the original news article, must be unique.
  url String @unique

  /// Sentiment analysis result of the article.
  sentiment String

  /// List of authors who wrote the article.
  authors String[]

  /// Summary or abstract of the news article.
  summary String?

  /// URL to the banner image of the article.
  bannerImage String?

  /// Publication time of the article.
  timePublished String

  /// Category or genre of the news article.
  category String?

  /// Topics covered in the news article.
  topics String[]

  /// URL to the logo image of the news source.
  logo String?

  /// Timestamp when the news article was added to the database. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the news article was last updated in the database. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  /// List of asset sentiments related to this news article. TYPESTRING.SKIP=true GQL.EXCLUDE=['news']
  assets NewsArticleAssetSentiment[]

  @@map(name: "news")
}

// Represents the sentiment of a news article towards a specific asset.
model NewsArticleAssetSentiment {
  /// Unique identifier for the sentiment record. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// Reference to the associated asset. TYPESTRING.SKIP=true
  assetId String @db.Uuid

  /// Reference to the associated news article. TYPESTRING.SKIP=true
  newsArticleId String @db.Uuid

  /// URL of the news article, must be unique.
  url String @unique

  /// Relation to the NewsArticle model. TYPESTRING.SKIP=true GQL.EXCLUDE=['assets']
  news NewsArticle @relation(fields: [newsArticleId], references: [id])

  /// Relation to the Asset model. TYPESTRING.INCLUDE=['symbol','name','type'] GQL.EXCLUDE=['newsMentions', 'trades', 'orders', 'positions']
  asset Asset @relation(fields: [assetId], references: [id], onDelete: Cascade)

  /// Relevancy score indicating how relevant the news is to the asset.
  relevancyScore String?

  /// Sentiment score derived from the news content.
  sentimentScore String?

  /// Label indicating the overall sentiment (e.g., Positive, Negative, Neutral).
  sentimentLabel String?
}

// Represents an economic event that may impact the markets.
model EconomicEvent {
  /// Unique identifier for the economic event. TYPESTRING.SKIP=true
  id String @id @default(uuid()) @db.Uuid

  /// Title or name of the economic event.
  title String

  /// Detailed description of the economic event.
  description String?

  /// Date and time when the economic event is scheduled to occur.
  date DateTime

  /// Importance level of the event, defined by EventImportance enum.
  importance EventImportance

  /// Timestamp when the economic event was created in the database. TYPESTRING.SKIP=true
  createdAt DateTime @default(now())

  /// Timestamp when the economic event was last updated in the database. TYPESTRING.SKIP=true
  updatedAt DateTime @default(now())

  @@map(name: "economic_events")
}
